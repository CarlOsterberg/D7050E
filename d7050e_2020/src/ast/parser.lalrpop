use std::str::FromStr;

use crate::ast::*;

grammar;

//-----------------------------------------------------
//Statement
//-----------------------------------------------------
pub Stmnt: Box<Root> = {
    Func,
    While,
    Let,
    Assign,
    If,
}

Func: Box<Root> = {
    "fn" <n:Var> "("<arg:FnArg>")" "->"<t:Kind> <b:Body> => Box::new(Root::Func(
        n,
        arg,
        t,
        b,
        None
    )),
    "fn" <n:Var> "()" "->"<t:Kind> <b:Body> => Box::new(Root::Func(
        n,
        vec!(),
        t,
        b,
        None
    )),
}

FnArg: Vec<(String,Type)> = {
    ArgList
}

ArgType: (String,Type) = {
    <Var>":"<Kind>
}

ArgList = Comma<ArgType>;

ParamList = Comma<Expr>;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Assign: Box<Root> = {
    <n:Var> "=" <e:Stmnt> ";" => Box::new(Root::Assign(
        n,
        e,
        None
    )),
    <n:Var> "=" <e:Expr> ";" => Box::new(Root::Assign(
        n,
        e,
        None
    )),
    
};

Let: Box<Root> = {
    "let" <m:"mut"?> <n:Var>":"<t:Kind> "=" <e:Stmnt> ";" => Box::new(Root::Let(
        if let Some(_) = m {"mut".to_string()} else {"read".to_string()},
        n,
        t,
        e,
        None
    )),
    "let" <m:"mut"?> <n:Var>":"<t:Kind> "=" <e:Expr> ";" => Box::new(Root::Let(
        if let Some(_) = m {"mut".to_string()} else {"read".to_string()},
        n,
        t,
        e,
        None
    ))
};

If: Box<Root> = {
    "if" <e:Expr> <ib:Body> => Box::new(Root::If(
        e,
        ib,
        None,
        None,
    )),
    "if" <e:Expr> <ib:Body> "else" <eb:Body> => Box::new(Root::If(
        e,
        ib,
        Some(eb),
        None,
    )),
}

While: Box<Root> = {
    "while" <e:Expr> <b:Body>=> Box::new(Root::While(
        e,
        b,
        None
    ))
}

Return: Box<Root> = {
    <Expr>
}

Body: Box<Root> = {
    "{" <Stmnts> "}"
}

Stmnts: Box<Root> = {
    <mut s1:Stmnt> <s2:Stmnts?> => match s2 {
        None => s1,
        Some(root) => {
            s1.next(*root);
            s1
        }
    }
}

//-----------------------------------------------------
//Expression
//-----------------------------------------------------

pub Expr: Box<Root> = {
    BoolAlg,
};

BoolAlg: Box<Root> = {
    BoolAlg BoolAlgOp Elemen => Box::new(Root::Infix(<>)),
    Elemen,
};

Elemen: Box<Root> = {
    Elemen ExprOp Factor => Box::new(Root::Infix(<>)),
    Factor,
};

Factor: Box<Root> = {
    Factor FactorOp Term => Box::new(Root::Infix(<>)),
    Term,
};

Term: Box<Root> = {
    PrefixOp Term => Box::new(Root::Prefix(<>)),
    FuncCall,
    Num => Box::new(Root::Number(<>)),
    Bool => Box::new(Root::Boolean(<>)),
    Var => Box::new(Root::Variable(<>)),
    "(" <Expr> ")"
};

FuncCall: Box<Root> = {
    <n:Var> "("<l:ParamList>")" => Box::new(Root::FuncCall(
        n,
        l
    )),
    <n:Var> "()" => Box::new(Root::FuncCall(
        n,
        vec!()
    ))
}

//translations

Kind: Type = {
    "i32" => Type::I32,
    "bool" => Type::Bool,
    "()" => Type::Unit,
}

PrefixOp: Opcode = {
    "-" => Opcode::Negate,
    "!" => Opcode::Not,
};

BoolAlgOp: Opcode = {
    "<" => Opcode::Less,
    ">" => Opcode::Greater,
    "||" => Opcode::Or,
    "&&" => Opcode::And,
    "==" => Opcode::Equals,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

//base terms, i32, bool 

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Bool: bool = {
    "true" => bool::from_str(<>).unwrap(),
    "false" => bool::from_str(<>).unwrap(),
}; 

Var: String = {
    r"(_|[a-z]|[A-Z])([a-z]|[A-Z]|[0-9]|_)*" => String::from_str(<>).unwrap(),
};